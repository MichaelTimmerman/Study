# Red Hat OpenShift Development II: Containerizing Applications (DO288)

## Deploying an Application to an OpenShift Cluster

The `oc new-app` command creates resources required to build and deploy and application to OpenShift.

* `--as-deployment-config`	(create DeploymentConfig instead of Deployment)
* `--image-stream or -i` (provide an image-stream -> S2I builder)
* `--strategy` (docker, pipeline or source)
* `--code` (URL to git repo)
* `--docker-image` (URL to container image)
* `--dry-run` (show result of operation without performing it -> set to true)
* `--context-dir` (set directory to treat as the root)

```bash
# Clone a git repo, building a container image & deploying it to an OpenShift cluster 
oc new-app https://github.com/RedHatTraining/DO288/tree/main/apps/apache-httpd
oc new-app https://github.com/RedHatTraining/DO288/tree/main/apps/apache-httpd#my-branch

# Existing docker image
oc new-app --docker-image=registry.access.redhat.com/rhel7-mysql57

# PHP S2I builder image
oc new-app php~http://gitserver.example.com/mygitrepo
oc new-app -i php http://gitserver.example.com/mygitrepo

# Specific tag (image stream)
oc new-app php:7.0~http://gitserver.example.com/mygitrepo
oc new-app -i php:7.0 http://gitserver.example.com/mygitrepo

# Same commands, different notation
oc new-app myis~http://gitserver.example.com/mygitrepo
oc new-app -i myis http://gitserver.example.com/mygitrepo
oc new-app -i myis --strategy source --code http://gitserver.example.com/mygitrepo
```

> Note: The tilde notation disables the language detection functionality of the oc new-app command. This allows the usage of an image stream that points to a builder for a programming language not known by the oc new-app command.

> The tilde (~) and --image-stream (-i) options do not work in the same way, the -i option requires the git client to be installed locally since the language detection needs to clone the repository so it can inspect the project and the tilde (~) notation does not.

> OpenShift inspects the contents of the URL and determines whether it is source code or a container image registry. To avoid ambiguity, use either the --code or the --docker-image options.

```bash
oc new-app --code http://gitserver.example.com/mygitrepo
oc new-app --docker-image registry.example.com/mycontainerimage
```

Deploy Existing Dockerfiles

```bash
oc new-app http://gitserver.example.com/mydockerfileproject
oc new-app --strategy docker http://gitserver.example.com/mydockerfileproject
oc new-app --strategy source http://gitserver.example.com/user/mygitrepo
```

Resources created by `oc new-app`:
* Build Configuration (build the container image from source or dockerfile)
* Deployment Configuration (deployment using the image stream)
* Application Image Stream (stream pointing to the generated image in the internal / external registry)
* Service (for all ports that the container image exposes)

Examples
```bash
# label db = mysql & some env vars
oc new-app mysql -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=testdb -l db=mysql
# using deployment config, php source (all generated resources get hello name)
oc new-app --as-deployment-config --name hello -i php --code http://gitserver.example.com/mygitrepo
```

Delete resources by label
```bash
oc delete all -l app=test
```

Inspect resource definitions, without applying
```bash
oc new-app -o json registry.example.com/mycontainerimage
```
Get list of supported options
```bash
oc new-app -h
```
> Having container image metadata in an image stream allows OpenShift to perform operations, such as image caching, based on this data instead of going to a registry server every time. It also allows using either notification or pooling strategies to react to image content updates.

The following example creates an image stream named myis for the acme/awesome container image that comes from the insecure registry at registry.acme.example.com
```bash
oc import-image myis --confirm --from registry.acme.example.com:5000/acme/awesome --insecure
```

